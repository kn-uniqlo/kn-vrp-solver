<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRP SOLVER - Route Optimization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6C5CE7;
            --secondary: #00B894;
            --accent: #FD79A8;
            --dark: #2D3436;
            --light: #F5F6FA;
            --success: #00B894;
            --warning: #FDCB6E;
            --danger: #E17055;
            --info: #0984E3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            min-height: 100vh;
            color: var(--dark);
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--primary) 0%, #8C7AE6 100%);
            padding: 25px;
            border-radius: 16px;
            color: white;
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            transform: rotate(30deg);
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            font-weight: 700;
            position: relative;
            text-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
            position: relative;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 25px;
            height: calc(100vh - 200px);
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(12px);
        }

        .map-container {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 2px 10px rgba(0,0,0,0.02);
            transition: all 0.3s ease;
        }

        .section:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            transform: translateY(-2px);
        }

        .section h3 {
            color: var(--dark);
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            color: var(--dark);
            font-size: 0.9rem;
        }

        input, select, button {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.02);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
            background: white;
        }

        button {
            background: linear-gradient(135deg, var(--primary) 0%, #8C7AE6 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(108, 92, 231, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, var(--secondary) 0%, #00D4A4 100%);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.3);
            transition: all 0.3s ease;
        }

        .file-input-wrapper:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 184, 148, 0.4);
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 9px;
            cursor: pointer;
            text-align: center;
            color: white;
            font-weight: 800;
            letter-spacing: 0.5px;
        }

        .parameters-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .data-table {
            max-height: 300px; /* กำหนดความสูงสูงสุด */
            overflow-y: auto;  /* ให้เลื่อนขึ้น-ลงได้ */
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-top: 10px;
            background: white;
        }

        .data-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .data-table th {
            background: rgba(0,0,0,0.02);
            font-weight: 600;
            top: 0; 
            color: var(--dark);
            box-shadow: 0 2px 2px -1px rgba(0,0,0,0.1); /* เพิ่มเงาเพื่อแยกหัวตาราง */
        }

        .data-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .data-table tr:hover td {
            background: rgba(108, 92, 231, 0.05);
        }

        .results-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid var(--primary);
            box-shadow: 0 2px 10px rgba(0,0,0,0.02);
        }

        .route-card {
            background: white;
            border-radius: 10px;
            padding: 18px;
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
            border-left: 4px solid var(--success);
            transition: all 0.3s ease;
        }

        .route-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .route-header {
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
        }

        .route-stats {
            font-size: 13px;
            color: rgba(0,0,0,0.6);
            background: rgba(0,0,0,0.03);
            padding: 4px 8px;
            border-radius: 20px;
        }

        .route-points {
            font-size: 14px;
            color: rgba(0,0,0,0.8);
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .time-windows {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .time-window {
            background: rgba(0,0,0,0.03);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-success { background-color: var(--success); }
        .status-warning { background-color: var(--warning); }
        .status-error { background-color: var(--danger); }
        .status-info { background-color: var(--info); }

        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #8C7AE6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: rgba(0,0,0,0.6);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 30px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(108, 92, 231, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .map-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            align-items: center;
        }

        .map-title {
            font-weight: 600;
            color: var(--dark);
            font-size: 1.1rem;
        }

        .map-actions {
            display: flex;
            gap: 10px;
        }

        .map-btn {
            background: rgb(137, 102, 252);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .map-btn:hover {
            background: rgba(0,0,0,0.02);
            border-color: rgba(0,0,0,0.2);
        }

        .time-slider {
            margin-top: 15px;
        }

        .time-slider input {
            width: 100%;
            margin-top: 8px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: var(--dark);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 13px;
            font-weight: normal;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(0,0,0,0.05);
            color: rgba(0,0,0,0.7);
        }

        .badge-primary {
            background: rgba(108, 92, 231, 0.1);
            color: var(--primary);
        }

        .badge-success {
            background: rgba(0, 184, 148, 0.1);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(253, 203, 110, 0.1);
            color: #d68910;
        }

        .badge-danger {
            background: rgba(225, 112, 85, 0.1);
            color: var(--danger);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .map-container {
                height: 500px;
            }
        }

        @media (max-width: 768px) {
            .parameters-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ROUTE PLANNER</h1>
            <p>Vehicle Routing Problem with Time Windows • 2025 Edition</p>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <!-- File Import Section -->
                <div class="section">
                    <h3>📂 Data Import</h3>
                    <div class="file-input-wrapper">
                        <input type="file" id="excelFile" accept=".xlsx,.xls" />
                        <label for="excelFile" class="file-input-label">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 5px;">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            Upload Excel Data
                        </label>
                    </div>
                    <p style="font-size: 13px; color: rgba(0,0,0,0.6); margin-top: 10px; line-height: 1.5;">
                        Required columns: <span class="badge">Location</span> <span class="badge">Demand</span> 
                        <span class="badge">Weight</span> <span class="badge">Start Time</span> 
                        <span class="badge">End Time</span> <span class="badge">Service Time</span>
                        <span class="badge">Latitude</span> <span class="badge">Longitude</span>
                    </p>
                </div>

                <!-- Parameters Section -->
                <div class="section">
                    <h3>⚙️ Optimization Parameters</h3>
                    <div class="parameters-grid">
                        <div class="form-group">
                            <label for="vehicleCount">
                                Vehicle Count 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Number of vehicles available for routing</span>
                                </span>
                            </label>
                            <input type="number" id="vehicleCount" value="10" min="1" max="20">
                        </div>
                        <div class="form-group">
                            <label for="maxCapacity">
                                Max Demand Capacity 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Maximum demand capacity per vehicle</span>
                                </span>
                            </label>
                            <input type="number" id="maxCapacity" value="400" min="1">
                        </div>
                        <div class="form-group">
                            <label for="maxWeight">
                                Max Weight Capacity 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Maximum weight capacity per vehicle</span>
                                </span>
                            </label>
                            <input type="number" id="maxWeight" value="3400" min="1">
                        </div>
                        <div class="form-group">
                            <label for="weightTolerance">
                                Weight Tolerance (%) 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">อนุญาตให้เกินน้ำหนักสูงสุดได้ไม่เกินกี่เปอร์เซ็นต์</span>
                                </span>
                            </label>
                            <input type="number" id="weightTolerance" value="5" min="0" max="30">
                        </div>
                        <div class="form-group">
                            <label for="depotLat">
                                Depot Latitude 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Starting point latitude coordinate</span>
                                </span>
                            </label>
                            <input type="number" id="depotLat" value="14.1871748" step="0.0001">
                        </div>
                        <div class="form-group">
                            <label for="depotLng">
                                Depot Longitude 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Starting point longitude coordinate</span>
                                </span>
                            </label>
                            <input type="number" id="depotLng" value="100.6226502" step="0.0001">
                        </div>
                        <div class="form-group">
                            <label for="timeHorizon">
                                Time Horizon (hrs) 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">Total working hours per vehicle</span>
                                </span>
                            </label>
                            <input type="number" id="timeHorizon" value="20" min="1" max="24">
                        </div>
                        <div class="form-group">
                            <label for="timeWindowPenalty">
                                Time Window Strictness 
                                <span class="tooltip">ℹ️
                                    <span class="tooltip-text">How strictly to enforce time windows (1-10)</span>
                                </span>
                            </label>
                            <select id="timeWindowPenalty">
                                <option value="1">Flexible</option>
                                <option value="3" selected>Balanced</option>
                                <option value="5">Strict</option>
                                <option value="10">Very Strict</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Optimization Button -->
                <div class="section">
                    <button id="optimizeBtn" onclick="optimizeRoutes()">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 5px;">
                            <path d="M3 3v7h7"></path>
                            <path d="M21 21v-7h-7"></path>
                            <path d="M21 3l-7 7"></path>
                            <path d="M3 21l7-7"></path>
                        </svg>
                        OPTIMIZE ROUTES
                    </button>
                </div>

                <!-- Loading Indicator -->
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Running AI-powered optimization...</p>
                    <div style="margin-top: 20px; font-size: 13px; color: rgba(0,0,0,0.6);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>Processing time windows...</span>
                            <span id="progressStatus">25%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 25%"></div>
                        </div>
                    </div>
                </div>

                <!-- Data Preview -->
                <div class="section" id="dataPreview" style="display: none;">
                    <h3>📊 Data Preview</h3>
                    <div class="data-table" id="dataTable"></div>
                </div>

                <!-- Results Section -->
                <div class="results-section" id="resultsSection" style="display: none;">
                    <h3>📈 Optimization Results</h3>
                    <div id="routeResults"></div>
                </div>
            </div>

            <div class="map-container">
                <div class="map-controls">
                    <div class="map-title">Route Visualization</div>
                    <div class="map-actions">
                        <button class="map-btn" id="animateBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            Animate
                        </button>
                        <button class="map-btn" id="exportBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Export
                        </button>
                    </div>
                </div>
                <div id="map"></div>
                <div class="time-slider" id="timeSlider" style="display: none;">
                    <label>Time Simulation: <span id="timeLabel">08:00</span></label>
                    <input type="range" min="0" max="480" value="0" step="15" id="timeRange">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let markers = [];
        let routeLines = [];
        let locationData = [];
        let depot = { lat: 14.1871748, lng: 100.6226502 };
        let currentAnimation = null;
        let currentTime = 0;
        let vehicleIcons = [];

        // Color palette for different routes
        const routeColors = [
            '#6C5CE7', '#00B894', '#FD79A8', '#FDCB6E', '#0984E3',
            '#E17055', '#00CEC9', '#A29BFE', '#FF7675', '#74B9FF',
            '#55EFC4', '#FFEAA7', '#81ECEC', '#FAB1A0', '#FF9FF3',
            '#D6A2E8', '#F8EFBA', '#CAD3C8', '#F97F51', '#1B9CFC',
            '#25CCF7', '#FD7272', '#9AECDB', '#D6A2E8', '#6D214F',
            '#182C61', '#3B3B98', '#FC427B', '#BDC581', '#82589F'
        ];

        // Vehicle icons for map
        const vehicleIconsList = [
            '🚚', '🚛', '🚐', '🚗', '🚙', '🚕', '🚌', '🚎', '🏎️', '🚓',
            '🚑', '🚒', '🚜', '🛵', '🚲', '🛴', '🚍', '🚔', '🚘', '🚖'
        ];

        // Initialize map
        function initMap() {
            map = L.map('map').setView([depot.lat, depot.lng], 11);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            // Add depot marker
            addDepotMarker();
            
            // Initialize vehicle icons
            for (let i = 0; i < 20; i++) {
                vehicleIcons.push(L.divIcon({
                    html: `<div style="background: ${routeColors[i % routeColors.length]}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); transform: translate(-50%, -50%);">${vehicleIconsList[i % vehicleIconsList.length]}</div>`,
                    iconSize: [10, 10],
                    className: 'vehicle-marker'
                }));
            }
        }

        function addDepotMarker() {
            const depotIcon = L.divIcon({
                html: '<div style="background: #E17055; color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; border: 2px solid white; box-shadow: 0 3px 8px rgba(0,0,0,0.3); transform: translate(-50%, -50%);">🏭</div>',
                iconSize: [10, 10],
                className: 'depot-marker'
            });

            L.marker([depot.lat, depot.lng], { icon: depotIcon })
                .addTo(map)
                .bindPopup('<b>Depot</b><br>Starting and Ending Point');
        }

        // File upload handler
        document.getElementById('excelFile').addEventListener('change', handleFileUpload);
        document.getElementById('animateBtn').addEventListener('click', toggleAnimation);
        document.getElementById('exportBtn').addEventListener('click', exportRoutes);
        document.getElementById('timeRange').addEventListener('input', updateTimeSimulation);

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    processExcelData(jsonData);
                } catch (error) {
                    alert('Error reading Excel file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function processExcelData(data) {
            // Clear previous data
            locationData = [];
            
            // Process each row in the Excel data
            data.forEach((row, index) => {
                const location = findColumn(row, ['Locations', 'Location', 'จุด', 'ที่ตั้ง']) || `Location ${index + 1}`;
                const demand = parseFloat(findColumn(row, ['Demand', 'ความต้องการ'])) || 0;
                const weight = parseFloat(findColumn(row, ['Weight', 'น้ำหนัก'])) || 0;
                
                // Improved time parsing with fallbacks
                let startTime = findColumn(row, ['Start times', 'Start time', 'เวลาเริ่มต้น']);
                let endTime = findColumn(row, ['End times', 'End time', 'เวลาสิ้นสุด']);
                
                // Handle different time formats
                const parseTime = (time) => {
                    if (time === undefined || time === null) return '08:00'; // Default fallback
                    
                    // If it's already in HH:MM format
                    if (typeof time === 'string' && time.match(/^\d{1,2}:\d{2}$/)) {
                        return time;
                    }
                    
                    // If it's an Excel time value (number)
                    if (typeof time === 'number') {
                        // Excel dates are represented as days since 1900 (with 1900 incorrectly treated as leap year)
                        const excelEpoch = new Date(1899, 11, 30);
                        const excelDate = new Date(excelEpoch.getTime() + Math.round(time * 86400 * 1000));
                        
                        // Handle 1900 leap year bug in Excel
                        if (time >= 60) time -= 1;
                        
                        const hours = excelDate.getHours().toString().padStart(2, '0');
                        const minutes = excelDate.getMinutes().toString().padStart(2, '0');
                        return `${hours}:${minutes}`;
                    }
                    
                    // If it's in other string formats
                    if (typeof time === 'string') {
                        // Handle formats like "8:00 AM" or "17:30:00"
                        const cleaned = time.replace(/\s+/g, '').toUpperCase();
                        const match = cleaned.match(/(\d{1,2}):(\d{2})(?::\d{2})?(AM|PM)?/);
                        if (match) {
                            let hours = parseInt(match[1]);
                            const minutes = match[2];
                            const period = match[3];
                            
                            if (period === 'PM' && hours < 12) hours += 12;
                            if (period === 'AM' && hours === 12) hours = 0;
                            
                            return `${hours.toString().padStart(2, '0')}:${minutes}`;
                        }
                        
                        // Handle decimal hours (e.g., 8.5 for 8:30)
                        const decimalMatch = cleaned.match(/^(\d+\.?\d*)$/);
                        if (decimalMatch) {
                            const decimalHours = parseFloat(decimalMatch[1]);
                            const hours = Math.floor(decimalHours);
                            const minutes = Math.round((decimalHours - hours) * 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                    
                    return '08:00'; // Final fallback
                };
                
                startTime = parseTime(startTime) || '08:00';
                endTime = parseTime(endTime) || '17:00';
                
                const serviceTime = parseFloat(findColumn(row, ['Service times', 'Service time', 'เวลาบริการ'])) || 30;
                const point = findColumn(row, ['Point', 'จุด']) || `P${index + 1}`;
                const lat = parseFloat(findColumn(row, ['Latitude', 'ละติจูด', 'lat', '(y)'])) || 0;
                const lng = parseFloat(findColumn(row, ['Longitude', 'ลองจิจูด', 'lng', 'lon', '(x)'])) || 0;

                // Convert time strings to minutes since midnight
                const startMinutes = timeToMinutes(startTime);
                const endMinutes = timeToMinutes(endTime);

                // Only add if we have valid coordinates
                if (lat !== 0 && lng !== 0) {
                    locationData.push({
                        id: index,
                        location: location,
                        demand: demand,
                        weight: weight,
                        startTime: startTime,
                        endTime: endTime,
                        startMinutes: startMinutes,
                        endMinutes: endMinutes,
                        serviceTime: serviceTime,
                        point: point,
                        lat: lat,
                        lng: lng,
                        visited: false
                    });
                }
            });

            // Update UI with the imported data
            displayDataPreview();
            addMarkersToMap();
            
            // Show success message
            if (locationData.length > 0) {
                showNotification(`Successfully imported ${locationData.length} locations`, 'success');
            } else {
                showNotification('No valid location data found. Please check your data format.', 'error');
            }
        }

        // Helper function to find column data (case insensitive)
        function findColumn(row, possibleNames) {
            for (const name of possibleNames) {
                // Check for exact match first
                if (row[name] !== undefined) {
                    return row[name];
                }
                
                // Check for case-insensitive match
                const lowerName = name.toLowerCase();
                for (const key in row) {
                    if (key.toLowerCase() === lowerName) {
                        return row[key];
                    }
                }
            }
            return null;
        }

        // Convert time string (HH:MM) to minutes since midnight
        function timeToMinutes(timeStr) {
            if (!timeStr) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        // Convert minutes since midnight to time string (HH:MM)
        function minutesToTime(totalMinutes) {
            // คำนวณชั่วโมงและนาที
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            
            // แปลงเป็นรูปแบบ HH:MM โดยตัดทศนิยมทิ้ง
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        function displayDataPreview() {
            const dataPreview = document.getElementById('dataPreview');
            const dataTable = document.getElementById('dataTable');
            
            if (locationData.length === 0) {
                dataPreview.style.display = 'none';
                return;
            }

            dataPreview.style.display = 'block';
            
            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>No.</th>
                            <th>Location</th>
                            <th>Time Window</th>
                            <th>Demand</th>
                            <th>Service Time</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            locationData.forEach((item, index) => {
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${item.location}</td>
                        <td>
                            ${item.startTime} - ${item.endTime}
                        </td>
                        <td>${item.demand}</td>
                        <td>${item.weight}</td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            dataTable.innerHTML = tableHTML;
        }

        function addMarkersToMap() {
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            locationData.forEach((location, index) => {
                const marker = L.marker([location.lat, location.lng], {
                    icon: L.divIcon({
                        html: `<div style="background: #6C5CE7; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                        iconSize: [10, 10],
                        className: 'location-marker'
                    })
                }).addTo(map)
                .bindPopup(`
                    <b>${location.point}: ${location.location}</b><br>
                    <div style="margin-top: 8px;">
                        <div><span class="badge">Time Window:</span> ${location.startTime} - ${location.endTime}</div>
                        <div><span class="badge">Demand:</span> ${location.demand}</div>
                        <div><span class="badge">Weight:</span> ${location.weight}</div>
                        <div><span class="badge">Service Time:</span> ${location.serviceTime} min</div>
                    </div>
                `);
                
                markers.push(marker);
            });

            // Fit map to show all markers
            if (locationData.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        function optimizeRoutes() {
            if (locationData.length === 0) {
                showNotification('Please import Excel data first', 'error');
                return;
            }

            // Show loading
            const loadingIndicator = document.getElementById('loadingIndicator');
            const optimizeBtn = document.getElementById('optimizeBtn');
            loadingIndicator.classList.add('show');
            optimizeBtn.disabled = true;

            // Get parameters
            const vehicleCount = parseInt(document.getElementById('vehicleCount').value);
            const maxCapacity = parseInt(document.getElementById('maxCapacity').value);
            const maxWeight = parseInt(document.getElementById('maxWeight').value);
            const timeHorizon = parseInt(document.getElementById('timeHorizon').value) * 60; 
            const timeWindowPenalty = parseInt(document.getElementById('timeWindowPenalty').value);
            
            // Update depot coordinates
            depot.lat = parseFloat(document.getElementById('depotLat').value);
            depot.lng = parseFloat(document.getElementById('depotLng').value);

            // Simulate progress updates
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 5;
                if (progress > 100) progress = 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressStatus').textContent = `${progress}%`;
                
                if (progress === 25) {
                    document.querySelector('#loadingIndicator p').textContent = "Analyzing time windows...";
                } else if (progress === 50) {
                    document.querySelector('#loadingIndicator p').textContent = "Calculating optimal routes...";
                } else if (progress === 75) {
                    document.querySelector('#loadingIndicator p').textContent = "Validating constraints...";
                } else if (progress === 100) {
                    document.querySelector('#loadingIndicator p').textContent = "Finalizing results...";
                }
            }, 200);

            // Simulate optimization process (in a real app, this would be an API call)
            setTimeout(() => {
                clearInterval(progressInterval);
                
                const routes = performVRPOptimization(vehicleCount, maxCapacity, maxWeight, timeHorizon, timeWindowPenalty);
                displayResults(routes);
                drawRoutesOnMap(routes);
                
                // Hide loading
                loadingIndicator.classList.remove('show');
                optimizeBtn.disabled = false;
                
                // Show completion notification
                showNotification('Route optimization completed successfully!', 'success');
            }, 5000);
        }

        function performVRPOptimization(vehicleCount, maxCapacity, maxWeight, timeHorizon, timeWindowPenalty) {
            // This is a simplified VRP with time windows implementation
            // In a real application, you would use a proper optimization algorithm
            
            // Reset visited status
            locationData.forEach(loc => loc.visited = false);

            const weightTolerance = parseInt(document.getElementById('weightTolerance').value) || 0;
            const effectiveMaxWeight = maxWeight * (1 + weightTolerance / 100);
            const routes = [];
            const unvisited = [...locationData];
            
            // Sort locations by earliest start time (time windows)
            unvisited.sort((a, b) => a.startMinutes - b.startMinutes);
            
            for (let v = 0; v < vehicleCount && unvisited.length > 0; v++) {
                const route = {
                    vehicle: v + 1,
                    stops: [],
                    sequence: [],
                    totalDemand: 0,
                    totalWeight: 0,
                    totalDistance: 0,
                    totalTime: 0,
                    timeWindows: [],
                    arrivalTimes: [],
                    departureTimes: [],
                    violations: 0
                };

                let currentTime = 0; // Starting from depot at time 0 (08:00)
                let currentLat = depot.lat;
                let currentLng = depot.lng;
                let remainingTime = timeHorizon;

                // Always start at depot
                route.sequence.push({ type: 'depot', lat: depot.lat, lng: depot.lng });
                route.arrivalTimes.push(0);
                route.departureTimes.push(0);

                while (unvisited.length > 0 && remainingTime > 0) {
                    // Find best next location based on time windows and distance
                    let bestIndex = -1;
                    let bestScore = -Infinity;
                    let bestArrivalTime = 0;
                    let bestWaitTime = 0;
                    let bestViolation = 0;

                    for (let i = 0; i < unvisited.length; i++) {
                        const location = unvisited[i];
                        const distance = calculateDistance(currentLat, currentLng, location.lat, location.lng);
                        const travelTime = distance * 3; // Assuming 20 km/h average speed
                        const arrivalTime = currentTime + travelTime;
                        
                        // Calculate time window violation
                        let waitTime = 0;
                        let violation = 0;
                        
                        if (arrivalTime < location.startMinutes) {
                            // Arrived too early, need to wait
                            waitTime = location.startMinutes - arrivalTime;
                        } else if (arrivalTime > location.endMinutes) {
                            // Arrived too late
                            violation = arrivalTime - location.endMinutes;
                        }
                        
                        const departureTime = arrivalTime + waitTime + location.serviceTime;
                        
                        // Check capacity and time constraints
                        if (route.totalDemand + location.demand > maxCapacity ||
                            route.totalWeight + location.weight > effectiveMaxWeight || // ใช้ effectiveMaxWeight แทน maxWeight
                            departureTime > timeHorizon) {
                            continue;
                        }
                        
                        // Calculate score (higher is better)
                        // This is a simple heuristic - in reality you'd use a proper optimization algorithm
                        const score = (1 / (distance + 1)) * 100 + 
                                     (1 / (violation + 1)) * 50 * timeWindowPenalty -
                                     waitTime * 0.5;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestIndex = i;
                            bestArrivalTime = arrivalTime;
                            bestWaitTime = waitTime;
                            bestViolation = violation;
                        }
                    }

                    if (bestIndex === -1) break; // No feasible location found

                    const selectedLocation = unvisited.splice(bestIndex, 1)[0];
                    route.stops.push(selectedLocation);
                    route.sequence.push({
                        type: 'location',
                        ...selectedLocation
                    });
                    
                    // Update times
                    route.arrivalTimes.push(bestArrivalTime);
                    route.departureTimes.push(bestArrivalTime + bestWaitTime + selectedLocation.serviceTime);
                    
                    // Update metrics
                    const distance = calculateDistance(currentLat, currentLng, selectedLocation.lat, selectedLocation.lng);
                    route.totalDemand += selectedLocation.demand;
                    route.totalWeight += selectedLocation.weight;
                    route.totalDistance += distance;
                    route.totalTime += bestWaitTime + selectedLocation.serviceTime;
                    route.timeWindows.push(`${minutesToTime(bestArrivalTime)} (${bestWaitTime > 0 ? 'wait ' + bestWaitTime + 'min' : 'on time'})`);
                    
                    if (bestViolation > 0) {
                        route.violations++;
                    }
                    
                    // Update current position and time
                    currentLat = selectedLocation.lat;
                    currentLng = selectedLocation.lng;
                    currentTime = bestArrivalTime + bestWaitTime + selectedLocation.serviceTime;
                    remainingTime = timeHorizon - currentTime;
                }

                // Return to depot
                const returnDistance = calculateDistance(currentLat, currentLng, depot.lat, depot.lng);
                const returnTime = returnDistance * 3;
                route.totalDistance += returnDistance;
                route.sequence.push({ type: 'depot', lat: depot.lat, lng: depot.lng });
                route.arrivalTimes.push(currentTime + returnTime);
                
                if (route.stops.length > 0) {
                    routes.push(route);
                }
            }

            // Handle any unvisited locations (in a real app, you'd need to handle this)
            if (unvisited.length > 0) {
                console.warn(`${unvisited.length} locations could not be visited with current constraints`);
            }

            return routes;
        }

        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function displayResults(routes) {
            const resultsSection = document.getElementById('resultsSection');
            const routeResults = document.getElementById('routeResults');
            
            resultsSection.style.display = 'block';
            
            // Get all parameters once at the start
            const maxCapacity = parseInt(document.getElementById('maxCapacity').value);
            const maxWeight = parseInt(document.getElementById('maxWeight').value);
            const weightTolerance = parseInt(document.getElementById('weightTolerance').value) || 0;
            const effectiveMaxWeight = maxWeight * (1 + weightTolerance / 100);
            const timeHorizon = parseInt(document.getElementById('timeHorizon').value) * 60;
            
            let resultsHTML = '';
            
            // Process each route
            routes.forEach((route, index) => {
                const utilizationDemand = (route.totalDemand / maxCapacity) * 100;
                const utilizationWeight = (route.totalWeight / maxWeight) * 100;
                const timeUtilization = (route.arrivalTimes[route.arrivalTimes.length - 1] / timeHorizon) * 100;
                const usedWeightTolerance = route.totalWeight > maxWeight;
                const overWeightPercentage = usedWeightTolerance ? 
                    ((route.totalWeight - maxWeight) / maxWeight * 100).toFixed(1) : 0;
                
                // Route card header
                resultsHTML += `
                    <div class="route-card" style="border-left-color: ${routeColors[index % routeColors.length]}">
                        <div class="route-header">
                            <span>🚛 Vehicle ${route.vehicle}</span>
                            <span class="route-stats">
                                ${route.stops.length} stops • ${route.totalDistance.toFixed(1)} km • 
                                ${minutesToTime(route.arrivalTimes[route.arrivalTimes.length - 1])}
                            </span>
                        </div>`;
                
                // Route points
                resultsHTML += `
                        <div class="route-points">
                            <strong>Route:</strong> Depot → 
                            ${route.stops.map((s, i) => 
                                `${s.point} (${minutesToTime(route.arrivalTimes[i+1])})`
                            ).join(' → ')} → Depot
                        </div>`;
                
                // Time windows
                resultsHTML += `
                        <div class="time-windows">
                            ${route.stops.map((s, i) => {
                                const arrival = route.arrivalTimes[i+1];
                                const status = arrival > s.endMinutes ? 'error' : 
                                            arrival < s.startMinutes ? 'warning' : 'success';
                                return `
                                    <div class="time-window">
                                        <span class="status-indicator status-${status}"></span>
                                        ${s.point}: ${minutesToTime(arrival)}
                                    </div>`;
                            }).join('')}
                        </div>`;
                
                // Progress bars
                resultsHTML += `
                        <div class="progress-container">
                            <div class="progress-labels">
                                <span>Demand: ${route.totalDemand} (${utilizationDemand.toFixed(1)}%)</span>
                                <span>Weight: ${route.totalWeight} (${utilizationWeight.toFixed(1)}%) 
                                    ${usedWeightTolerance ? 
                                        `<span class="badge badge-warning">
                                            +${weightTolerance}% Tolerance
                                        </span>` : ''}
                                </span>
                                <span>Time: ${minutesToTime(route.arrivalTimes[route.arrivalTimes.length - 1])} (${timeUtilization.toFixed(1)}%)</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${Math.min(100, utilizationWeight)}%; 
                                    background: ${
                                        route.totalWeight > effectiveMaxWeight ? 'var(--danger)' :
                                        route.totalWeight > maxWeight ? 'var(--warning)' : 'var(--success)'
                                    }">
                                </div>
                            </div>
                        </div>`;
                
                // Violation warnings
                if (route.violations > 0) {
                    resultsHTML += `
                        <div style="margin-top: 5px; font-size: 12px; color: var(--info);">
                            ⚠️ ${route.violations} time window violation(s)
                        </div>`;
                }
                
                if (usedWeightTolerance) {
                    resultsHTML += `
                        <div style="margin-top: 5px; font-size: 12px; color: var(--warning);">
                            ⚖️ Used weight tolerance: ${route.totalWeight.toFixed(0)}/${maxWeight} kg 
                            (${overWeightPercentage}% over)
                        </div>`;
                }
                
                resultsHTML += `</div>`; // Close route-card
            });

            // Summary section
            const totalDistance = routes.reduce((sum, route) => sum + route.totalDistance, 0);
            const totalStops = routes.reduce((sum, route) => sum + route.stops.length, 0);
            const totalViolations = routes.reduce((sum, route) => sum + route.violations, 0);
            const avgUtilization = routes.length > 0 ? 
                routes.reduce((sum, route) => sum + (route.totalDemand / maxCapacity * 100), 0) / routes.length : 0;
            const maxWeightUsed = Math.max(...routes.map(r => r.totalWeight));
            const overWeightRoutes = routes.filter(r => r.totalWeight > maxWeight).length;
            
            resultsHTML += `
                <div style="background: rgba(0,0,0,0.02); padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <h4 style="color: var(--dark); margin-bottom: 10px;">📊 Summary</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 12px;">
                        <div><strong>Total Vehicles:</strong> ${routes.length}</div>
                        <div><strong>Total Distance:</strong> ${totalDistance.toFixed(1)} km</div>
                        <div><strong>Total Stops:</strong> ${totalStops}</div>
                        <div><strong>Unassigned Stops:</strong> ${locationData.length - totalStops}</div>
                        <div><strong>Avg. Utilization:</strong> ${avgUtilization.toFixed(1)}%</div>
                        <div><strong>Total Violations:</strong> ${totalViolations}</div>
                        <div><strong>Weight Tolerance:</strong> +${weightTolerance}%</div>
                        <div><strong>Max Weight Used:</strong> ${maxWeightUsed.toFixed(0)} kg</div>
                        <div><strong>Over Weight Routes:</strong> ${overWeightRoutes}</div>
                    </div>
                </div>`;
            
            routeResults.innerHTML = resultsHTML;
        }

        function drawRoutesOnMap(routes) {
            // Clear existing routes and vehicles
            routeLines.forEach(line => map.removeLayer(line));
            routeLines = [];
            
            // Remove any existing vehicle markers
            map.eachLayer(layer => {
                if (layer.options && layer.options.icon && layer.options.icon.options && 
                    (layer.options.icon.options.className === 'vehicle-marker' || 
                     layer.options.icon.options.className === 'active-vehicle')) {
                    map.removeLayer(layer);
                }
            });

            // Update depot marker position
            map.eachLayer(layer => {
                if (layer.options && layer.options.icon && layer.options.icon.options && 
                    layer.options.icon.options.className === 'depot-marker') {
                    map.removeLayer(layer);
                }
            });
            addDepotMarker();

            // Draw each route
            routes.forEach((route, routeIndex) => {
                const color = routeColors[routeIndex % routeColors.length];
                const points = [];
                
                // Add all points in sequence
                route.sequence.forEach(point => {
                    points.push([point.lat, point.lng]);
                });
                
                // Draw route line
                const routeLine = L.polyline(points, {
                    color: color,
                    weight: 4,
                    opacity: 0.7,
                    dashArray: routeIndex === 0 ? null : '5, 5'
                }).addTo(map);
                
                routeLine.bindPopup(`
                    <b>Vehicle ${route.vehicle}</b><br>
                    <div style="margin-top: 8px;">
                        ${route.stops.map((stop, i) => `
                            <div style="margin-bottom: 5px;">
                                <b>${stop.point}:</b> ${minutesToTime(route.arrivalTimes[i+1])}<br>
                                <small>Window: ${stop.startTime}-${stop.endTime}</small>
                            </div>
                        `).join('')}
                        <div style="margin-top: 5px;">
                            <b>Total:</b> ${route.stops.length} stops, ${route.totalDistance.toFixed(1)} km
                        </div>
                    </div>
                `);
                routeLines.push(routeLine);
                
                // Update marker colors for this route
                route.stops.forEach((stop, stopIndex) => {
                    const marker = markers.find(m => 
                        Math.abs(m.getLatLng().lat - stop.lat) < 0.0001 && 
                        Math.abs(m.getLatLng().lng - stop.lng) < 0.0001
                    );
                    
                    if (marker) {
                        const icon = L.divIcon({
                            html: `<div style="background: ${color}; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${stopIndex + 1}</div>`,
                            iconSize: [10, 10],
                            className: 'route-marker'
                        });
                        marker.setIcon(icon);
                    }
                });
            });

            // Show time slider if we have routes
            if (routes.length > 0) {
                document.getElementById('timeSlider').style.display = 'block';
                currentTime = 0;
                updateTimeSimulation();
            } else {
                document.getElementById('timeSlider').style.display = 'none';
            }
        }

        function toggleAnimation() {
            if (currentAnimation) {
                clearInterval(currentAnimation);
                currentAnimation = null;
                document.getElementById('animateBtn').textContent = 'Animate';
                return;
            }
            
            document.getElementById('animateBtn').textContent = 'Stop';
            const timeSlider = document.getElementById('timeRange');
            let time = parseInt(timeSlider.value);
            
            currentAnimation = setInterval(() => {
                time += 15;
                if (time > 480) time = 0;
                timeSlider.value = time;
                updateTimeSimulation();
            }, 200);
        }

        function updateTimeSimulation() {
            const timeValue = parseInt(document.getElementById('timeRange').value);
            currentTime = timeValue;
            document.getElementById('timeLabel').textContent = minutesToTime(timeValue);
            
            // In a real app, you would update vehicle positions based on the current time
            // This is a simplified visualization
        }

        function exportRoutes() {
            // In a real app, implement export functionality
            showNotification('Export feature coming soon!', 'info');
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="status-indicator status-${type}"></span>
                    ${message}
                </div>
            `;
            
            // Style the notification
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.padding = '15px 20px';
            notification.style.background = 'white';
            notification.style.borderRadius = '8px';
            notification.style.boxShadow = '0 5px 15px rgba(0,0,0,0.1)';
            notification.style.zIndex = '1000';
            notification.style.transform = 'translateY(100px)';
            notification.style.opacity = '0';
            notification.style.transition = 'all 0.3s ease';
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateY(0)';
                notification.style.opacity = '1';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.transform = 'translateY(100px)';
                notification.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
        });
    </script>
</body>
</html>
